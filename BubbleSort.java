import java.util.Arrays; // Импортируем класс Arrays для удобного преобразования массива в строку (Arrays.toString) для вывода.
import java.util.Scanner; // Импортируем класс Scanner для чтения ввода данных от пользователя через консоль.

public class BubbleSort { // Объявление публичного класса BubbleSort, в котором содержится вся логика программы.

    // 1. Метод сортировки
    /**
     * Сортирует массив целых чисел с использованием алгоритма сортировки пузырьком.
     * @param arr Массив, который будет отсортирован.
     */
    public static void bubbleSort(int[] arr) { // Объявление статического метода сортировки, принимающего массив целых чисел.
        int n = arr.length; // Получаем общее количество элементов в массиве и сохраняем его в переменной n.
        boolean swapped;    // Объявляем булеву переменную-флаг для оптимизации. Она будет true, если произошел обмен.

        // Внешний цикл: Он определяет количество проходов, необходимых для сортировки.
        // Нам достаточно n-1 прохода.
        for (int i = 0; n - 1 > i; i++) {
            swapped = false; // Сбрасываем флаг в false в начале каждого нового прохода.

            // Внутренний цикл: Выполняет фактическое сравнение и обмен соседних пар.
            // (n - 1 - i) – длина прохода сокращается, так как последние 'i' элементов уже отсортированы.
            for (int j = 0; n - 1 - i > j; j++) {

                // Проверка: Если текущий элемент (arr[j]) больше следующего (arr[j+1]), они в неправильном порядке.
                if (arr[j] > arr[j + 1]) {
                    // Обмен (Своп): Блок кода для перестановки двух элементов.
                    int temp = arr[j];      // Шаг 1: Сохраняем значение текущего элемента во временной переменной.
                    arr[j] = arr[j + 1];    // Шаг 2: Присваиваем текущему элементу значение следующего (перезаписываем).
                    arr[j + 1] = temp;      // Шаг 3: Присваиваем следующему элементу сохраненное временное значение.

                    swapped = true; // Фиксируем, что в этом проходе произошел хотя бы один обмен.
                }
            }

            // Оптимизация: Если флаг 'swapped' остался false (то есть обменов не было)...
            if (!swapped) break; // ...значит, массив уже отсортирован, и мы прерываем выполнение внешнего цикла.
        }
    }

    // 2. Основной метод с вводом
    public static void main(String[] args) { // Основной метод, с которого начинается выполнение программы.
        // Инициализация Scanner и запрос размера массива у пользователя.
        Scanner scanner = new Scanner(System.in); // Создаем объект Scanner для чтения данных из стандартного ввода (консоли).
        System.out.print("Введите размер массива: "); // Выводим пользователю запрос на ввод размера.
        int size = scanner.nextInt(); // Считываем введенное пользователем целое число (размер) и сохраняем его в size.

        // Создание и заполнение массива.
        int[] data = new int[size]; // Создаем новый массив целых чисел с размером, заданным пользователем.
        System.out.println("Введите " + size + " чисел:"); // Информируем пользователя о количестве требуемых чисел.

        // Цикл для последовательного заполнения всех ячеек массива.
        for (int i = 0; i < size; i++) {
            System.out.print("Элемент [" + i + "]: "); // Выводим подсказку, какой элемент вводится в данный момент.
            data[i] = scanner.nextInt(); // Считываем следующее целое число и записываем его в текущую ячейку массива.
        }
        scanner.close(); // Закрываем объект Scanner для освобождения системных ресурсов.

        // Сортировка и вывод результата.
        System.out.println("\nИсходный массив: " + Arrays.toString(data)); // Выводим исходный массив до начала сортировки.
        bubbleSort(data); // Вызываем наш метод сортировки, передавая ему массив.
        System.out.println("Отсортированный массив: " + Arrays.toString(data)); // Выводим массив после выполнения сортировки.
    }
}
